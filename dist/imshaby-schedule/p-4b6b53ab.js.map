{"version":3,"names":["D","getWeekDay","date","dateTS","Date","parse","this","daysNames","getDay","getToday","today","getWeekName","index","strToDate","dtStr","dateParts","split","timeParts","standardDays"],"sources":["src/utils/days.ts"],"sourcesContent":["export class D {\r\n\r\n  static readonly standardDays = ['1', '2', '3', '4', '5', '6', '7']\r\n  static readonly daysNames = ['Нд', 'Пн', 'Ат', 'Ср', 'Чц', 'Пт', 'Сб']\r\n\r\n  static getWeekDay(date: string): string {\r\n    let dateTS = Date.parse(date)\r\n\r\n    return this.daysNames[new Date(dateTS).getDay()]\r\n  }\r\n\r\n  static getToday(): Date {\r\n    let today = new Date()\r\n\r\n    return today\r\n  }\r\n\r\n  static getWeekName(index: any): string {\r\n    if (index == 7) { index = 0 }\r\n    return this.daysNames[index]\r\n  }\r\n\r\n  static strToDate(dtStr): Date {\r\n    if (!dtStr) return null\r\n    let dateParts = dtStr.split(\"-\");\r\n    let timeParts = dateParts[2].split(\" \")[1].split(\":\");\r\n    dateParts[2] = dateParts[2].split(\" \")[0];\r\n    // month is 0-based, that's why we need dataParts[1] - 1\r\n    return new Date(+dateParts[2], dateParts[1] - 1, +dateParts[0], timeParts[0], timeParts[1], timeParts[2]);\r\n  }\r\n}\r\n"],"mappings":"MAAaA,EAKX,iBAAOC,CAAWC,GAChB,IAAIC,EAASC,KAAKC,MAAMH,GAExB,OAAOI,KAAKC,UAAU,IAAIH,KAAKD,GAAQK,S,CAGzC,eAAOC,GACL,IAAIC,EAAQ,IAAIN,KAEhB,OAAOM,C,CAGT,kBAAOC,CAAYC,GACjB,GAAIA,GAAS,EAAG,CAAEA,EAAQ,C,CAC1B,OAAON,KAAKC,UAAUK,E,CAGxB,gBAAOC,CAAUC,GACf,IAAKA,EAAO,OAAO,KACnB,IAAIC,EAAYD,EAAME,MAAM,KAC5B,IAAIC,EAAYF,EAAU,GAAGC,MAAM,KAAK,GAAGA,MAAM,KACjDD,EAAU,GAAKA,EAAU,GAAGC,MAAM,KAAK,GAEvC,OAAO,IAAIZ,MAAMW,EAAU,GAAIA,EAAU,GAAK,GAAIA,EAAU,GAAIE,EAAU,GAAIA,EAAU,GAAIA,EAAU,G,EA1BxFjB,EAAAkB,aAAe,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC9ClB,EAAAO,UAAY,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,a","ignoreList":[]}